use crate::engine::Engine;

#[derive(Debug)]
#[cfg(not(feature = "flatbuffers-storage"))]
pub enum SerializeError {
    DataFormatError(crate::data_format::SerializationError),
}

#[derive(Debug)]
#[cfg(feature = "flatbuffers-storage")]
pub enum SerializeError {
    FlatbuffersError(),
}

#[derive(Debug)]
#[cfg(not(feature = "flatbuffers-storage"))]
pub enum DeserializeError {
    DataFormatError(crate::data_format::DeserializationError),
}

#[derive(Debug)]
#[cfg(feature = "flatbuffers-storage")]
pub enum DeserializeError {
    FlatbuffersError(),
}

#[cfg(not(feature = "flatbuffers-storage"))]
impl From<crate::data_format::SerializationError> for SerializeError {
    fn from(value: crate::data_format::SerializationError) -> Self {
        SerializeError::DataFormatError(value)
    }
}

#[cfg(not(feature = "flatbuffers-storage"))]
impl From<crate::data_format::DeserializationError> for DeserializeError {
    fn from(value: crate::data_format::DeserializationError) -> Self {
        DeserializeError::DataFormatError(value)
    }
}

pub trait EngineSerializer {
    fn serialize_raw(&self) -> Result<Vec<u8>, SerializeError>;
    fn deserialize(&mut self, serialized: &[u8]) -> Result<(), DeserializeError>;
}

#[cfg(feature = "flatbuffers-storage")]
impl EngineSerializer for Engine {
    fn serialize_raw(&self) -> Result<Vec<u8>, SerializeError> {
        Err(SerializeError::FlatbuffersError())
    }

    fn deserialize(&mut self, _serialized: &[u8]) -> Result<(), DeserializeError> {
        Err(DeserializeError::FlatbuffersError())
    }
}

#[cfg(not(feature = "flatbuffers-storage"))]
impl EngineSerializer for Engine {
    /// Serializes the `Engine` into a binary format so that it can be quickly reloaded later.
    fn serialize_raw(&self) -> Result<Vec<u8>, SerializeError> {
        use crate::data_format::SerializeFormat;

        let serialize_format = SerializeFormat::build(&self.blocker, &self.cosmetic_cache);

        let result = serialize_format.serialize()?;
        Ok(result)
    }

    /// Deserialize the `Engine` from the binary format generated by `Engine::serialize_raw`. The
    /// method will automatically select the correct deserialization implementation.
    fn deserialize(&mut self, serialized: &[u8]) -> Result<(), DeserializeError> {
        use crate::data_format::DeserializeFormat;
        let current_tags = self.blocker.tags_enabled();
        let deserialize_format = DeserializeFormat::deserialize(serialized)?;
        let (blocker, cosmetic_cache) = deserialize_format.build();
        self.blocker = blocker;
        self.blocker
            .use_tags(&current_tags.iter().map(|s| &**s).collect::<Vec<_>>());
        self.cosmetic_cache = cosmetic_cache;
        Ok(())
    }
}
